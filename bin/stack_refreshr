#!/usr/bin/env bash
set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# Defaults (top of main)
export SR_SHOW_SYSTEM="${SR_SHOW_SYSTEM:-0}"

export SR_ROOT="$ROOT"
export SR_CONF="${SR_CONF:-$ROOT/configuration}"
export SR_LIB="$ROOT/lib"
export SR_LOGS="${SR_LOGS:-$ROOT/logs}"
export SR_STATE="${SR_STATE:-$ROOT/state}"

export SET_ALIASES="${SET_ALIASES:-0}"

# Flags
export DRY_RUN="${DRY_RUN:-0}"
export VERBOSE="${VERBOSE:-0}"
export PARALLEL="${PARALLEL:-1}"

export HOMEBREW_NO_AUTO_UPDATE=1
export HOMEBREW_NO_INSTALL_CLEANUP=1
export HOMEBREW_NO_ENV_HINTS=1

export TELEM_ENABLED TELEM_DRY_RUN

# Auto-load domain files
for f in "$SR_LIB"/domain_*.sh; do [ -r "$f" ] && . "$f"; done

# put near the very top, before arg parsing
if [ "${1:-}" = "__complete" ]; then
  case "${2:-}" in
    domains)
      cat <<'OUT'
1:Terminal & UX
2:SSH & Key Management
3:Git & Source Control
4:Code & Dev Tools
5:Containers & Runtimes
6:Kubernetes (Local Dev)
7:Secrets & Certs
8:Observability & Logs
9:Infrastructure as Code
10:Automation & Scheduling
11:Bonus Tools (CLI Suite)
A:Install ALL MUST (all domains)
Q:Quit
OUT
      ;;
  esac
  exit 0
fi

# Helpers
have(){ command -v "$1" >/dev/null 2>&1; }
warn(){ printf "‚ö†Ô∏è  %s\n" "$*" >&2; }
usage(){
  cat <<EOF
stack_refreshr
Usage: stack_refreshr [--dry-run] [--verbose] [--sequential] [--enable-telemetry] [--telemetry-config FILE]
       stack_refreshr telemetry {explain|show|dryrun}
Flags:
  --dry-run            Show what would happen, don't install
  --verbose            Print underlying commands
  --sequential         Disable parallel installs
  --enable-telemetry   Enable telemetry for this run (can also be enabled in config)
  --telemetry-config   Path to telemetry.json (default: ~/.config/stack_refreshr/telemetry.json)
EOF
}

# Parse args (includes telemetry subcommands)
while [ $# -gt 0 ]; do
  case "$1" in
    --dry-run) DRY_RUN=1 ;;
    --show-system) SR_SHOW_SYSTEM=1 ;;
    --verbose) VERBOSE=1 ;;
    --sequential) PARALLEL=0 ;;
    --enable-telemetry) TELEM_ENABLED=1 ;;
    --telemetry-config) shift; SR_TELEM_CFG="$1" ;;
    telemetry)
      shift
      . "$SR_LIB/telemetry.sh"   # make sure CLI subcommands can run even outside menu
      case "${1:-}" in
        explain)
          cat <<'TXT'
Telemetry is opt-in. We collect anonymous domain/status/version/duration/timestamps.
Upload uses GitHub Gist. No token in code. Token is discovered from env/gh/keychain.
TXT
          exit 0
          ;;
        show)
          echo "Config file: ${SR_TELEM_CFG:-unset}"
          [ -s "${SR_TELEM_CFG:-}" ] && cat "$SR_TELEM_CFG" || echo "(no config file)"
          exit 0
          ;;
        dryrun)
          TELEM_DRY_RUN=1
          export TELEM_DRY_RUN TELEM_ENABLED
          telemetry_send_event "telemetry" "dryrun" 0 "n/a" '{"note":"dry-run test"}'
          exit 0
          ;;
        *)
          echo "Usage: stack_refreshr telemetry {explain|show|dryrun}"
          exit 1
          ;;
      esac
      ;;
    --set-aliases) SET_ALIASES=1 ;;
    aliases)
      shift
      . "$SR_LIB/aliases.sh"
      case "${1:-}" in
        restore) sr_remove_aliases; exit 0 ;;
        status)  shift || true
                 if [ "${1:-}" = "--json" ]; then sr_aliases_status --json; else sr_aliases_status; fi
                 exit 0 ;;
        *) echo "Usage: stack_refreshr aliases {restore|status [--json]}"; exit 1 ;;
      esac
      ;;
    -h|--help) usage; exit 0 ;;
    *) warn "Unknown arg: $1" ;;
  esac
  shift
done

mkdir -p "$SR_LOGS" "$SR_STATE"

# Source libs
. "$SR_LIB/preflight.sh"
. "$SR_LIB/ui.sh"
. "$SR_LIB/install.sh"
. "$SR_LIB/helpers.sh"
. "$SR_LIB/domain_loader.sh"
. "$SR_LIB/aliases.sh"
. "$SR_LIB/timer.sh"
. "$SR_LIB/telemetry.sh"
. "$SR_LIB/install_completions.sh"

[ "$SET_ALIASES" = "1" ] && sr_apply_aliases

# Map menu numbers -> domain functions
declare -A domain_map=(
  [1]=sr_domain_01_terminal
  [2]=sr_domain_02_ssh
  [3]=sr_domain_03_git
  [4]=sr_domain_04_code
  [5]=sr_domain_05_containers
  [6]=sr_domain_06_k8s
  [7]=sr_domain_07_secrets
  [8]=sr_domain_08_observability
  [9]=sr_domain_09_iac
  [10]=sr_domain_10_automation
)

# Order for ALL MUST
domain_order=(1 2 3 4 5 6 7 8 9 10)

# Utility: make a nice domain slug for telemetry (e.g., "domain_01_terminal")
sr_domain_slug() {
  local num="$1"
  local fn="${domain_map[$num]:-unknown}"
  printf '%s' "$fn"
}

# Run a domain by numeric key, with mode (full|must), with timer + telemetry
# Run a domain by numeric key, with a given mode (default: full)
sr_run_domain() {
  local num="$1"; shift || true
  local mode="${1:-full}"
  local fn="${domain_map[$num]:-}"

  if [ -z "$fn" ]; then
    warn "No domain mapped for: $num"
    return 1
  fi

  # measure duration (independent of pretty timer output)
  local _start _end _dur
  _start=$(date +%s)

  # pretty timer + error-safe run
  timer_wrap "$fn" sr_run_or_warn "$fn" "$mode"

  _end=$(date +%s)
  _dur=$((_end - _start))

  # Telemetry (opt-in) ‚Äî domain name is the function name, status "complete"
  # Include mode for context (full/must/etc)
  if telemetry_enabled; then
    telemetry_send_event "$fn" "complete" "$_dur" "" "{\"mode\":\"$mode\"}"
  fi
}

# ALL MUST using same map/order
sr_install_all_must() {
  say "üöÄ Installing ALL MUST tools across domains‚Ä¶"
  local _start _end _dur
  _start=$(date +%s)

  timer_start "all_must"
  for i in "${domain_order[@]}"; do
    sr_run_domain "$i" "must"
  done
  timer_end_say "all_must"

  _end=$(date +%s)
  _dur=$((_end - _start))

  if telemetry_enabled; then
    telemetry_send_event "all_must" "complete" "$_dur" "" '{"mode":"must"}'
  fi
}

# Run
preflight

# Menu loop
while true; do
  choice="$(sr_menu_main || true)"
  [ -n "${choice:-}" ] || continue

  case "${choice^^}" in
    [1-9]|10)
      sr_run_domain "$choice" "full"
      ;;
    A)
      sr_install_all_must
      ;;
    Q)
      printf "üëã Bye!\n"; exit 0
      ;;
    *)
      printf "‚ö†Ô∏è  Invalid choice: %s\n" "$choice"
      ;;
  esac
done
