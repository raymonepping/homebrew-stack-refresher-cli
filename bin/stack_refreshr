#!/usr/bin/env bash
set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
export SR_ROOT="$ROOT"
export SR_CONF="${SR_CONF:-$ROOT/configuration}"
export SR_LIB="$ROOT/lib"
export SR_LOGS="${SR_LOGS:-$ROOT/logs}"
export SR_STATE="${SR_STATE:-$ROOT/state}"

export SET_ALIASES="${SET_ALIASES:-0}"

# Flags
export DRY_RUN="${DRY_RUN:-0}"
export VERBOSE="${VERBOSE:-0}"
export PARALLEL="${PARALLEL:-1}"

# Telemetry defaults
export SR_TELEM_CFG="${SR_TELEM_CFG:-$HOME/.config/stack_refreshr/telemetry.json}"
export TELEM_ENABLED="${TELEM_ENABLED:-0}"
export TELEM_DRY_RUN="${TELEM_DRY_RUN:-0}"

# Homebrew noise control
export HOMEBREW_NO_AUTO_UPDATE=1
export HOMEBREW_NO_INSTALL_CLEANUP=1
export HOMEBREW_NO_ENV_HINTS=1

# Load domain entrypoints
for f in "$SR_LIB"/domain_*.sh; do [ -r "$f" ] && . "$f"; done

# Helpers
have(){ command -v "$1" >/dev/null 2>&1; }
warn(){ printf "‚ö†Ô∏è  %s\n" "$*" >&2; }
usage(){
  cat <<EOF
stack_refreshr
Usage: stack_refreshr [--dry-run] [--verbose] [--sequential] [--enable-telemetry] [--telemetry-config PATH]
Flags:
  --dry-run             Show what would happen, don't install
  --verbose             Print underlying commands
  --sequential          Disable parallel installs
  --enable-telemetry    Enable telemetry for this run (opt-in)
  --telemetry-config    Override telemetry config path

Commands:
  telemetry explain     Show what is collected and why
  telemetry show        View current telemetry config
  telemetry dryrun      Simulate a telemetry send (no upload)
  aliases {restore|status [--json]}
EOF
}

# Args
while [ $# -gt 0 ]; do
  case "$1" in
    --dry-run) DRY_RUN=1 ;;
    --verbose) VERBOSE=1 ;;
    --sequential) PARALLEL=0 ;;
    --enable-telemetry) TELEM_ENABLED=1 ;;
    --telemetry-config)
      shift
      if [ $# -eq 0 ]; then warn "--telemetry-config requires a path"; exit 1; fi
      SR_TELEM_CFG="$1"
      ;;
    telemetry)
      shift || true
      sub="${1:-}"; shift || true
      case "$sub" in
        explain)
          cat <<'TXT'
Telemetry is opt-in. We collect anonymous domain/status/version/duration/timestamps.
Upload uses GitHub Gist via gh or token from env/keychain. No usernames, no paths.
Use --enable-telemetry and put your Gist ID in ~/.config/stack_refreshr/telemetry.json.
TXT
          exit 0
          ;;
        show)
          echo "Config path: ${SR_TELEM_CFG:-unset}"
          if [ -s "${SR_TELEM_CFG:-}" ]; then
            cat "$SR_TELEM_CFG"
          else
            echo "(no config file)"
          fi
          exit 0
          ;;
        dryrun)
          TELEM_DRY_RUN=1; TELEM_ENABLED=1
          export TELEM_DRY_RUN TELEM_ENABLED SR_TELEM_CFG
          . "$SR_LIB/telemetry.sh" 2>/dev/null || true
          # domain, tool, duration, version, extra_json
          telemetry_send_event "telemetry" "dryrun" 0 "n/a" '{"note":"dry-run test"}' || true
          exit 0
          ;;
        *)
          echo "Usage: stack_refreshr telemetry {explain|show|dryrun}"; exit 1 ;;
      esac
      ;;
    --set-aliases) SET_ALIASES=1 ;;
    aliases)
      shift || true
      . "$SR_LIB/aliases.sh"
      case "${1:-}" in
        restore) sr_remove_aliases; exit 0 ;;
        status)
          shift || true
          if [ "${1:-}" = "--json" ]; then sr_aliases_status --json; else sr_aliases_status; fi
          exit 0
          ;;
        *) echo "Usage: stack_refreshr aliases {restore|status [--json]}"; exit 1 ;;
      esac
      ;;
    -h|--help) usage; exit 0 ;;
    *) warn "Unknown arg: $1" ;;
  esac
  shift
done

mkdir -p "$SR_LOGS" "$SR_STATE"

# Source libs
. "$SR_LIB/preflight.sh"
. "$SR_LIB/ui.sh"
. "$SR_LIB/install.sh"
. "$SR_LIB/helpers.sh"
. "$SR_LIB/domain_loader.sh"
. "$SR_LIB/aliases.sh"
. "$SR_LIB/timer.sh"

# Load telemetry last (after helpers so 'say' exists); only if enabled/dryrun
if [ "${TELEM_ENABLED:-0}" = "1" ] || [ "${TELEM_DRY_RUN:-0}" = "1" ]; then
  export SR_TELEM_CFG TELEM_ENABLED TELEM_DRY_RUN
  . "$SR_LIB/telemetry.sh" 2>/dev/null || true
fi

[ "$SET_ALIASES" = "1" ] && sr_apply_aliases

# Map menu numbers to domain functions (single source of truth)
declare -A domain_map=(
  [1]=sr_domain_01_terminal
  [2]=sr_domain_02_ssh
  [3]=sr_domain_03_git
  [4]=sr_domain_04_code
  [5]=sr_domain_05_containers
  [6]=sr_domain_06_k8s
  [7]=sr_domain_07_secrets
  [8]=sr_domain_08_observability
  [9]=sr_domain_09_iac
  [10]=sr_domain_10_automation
)
# Explicit order for ALL MUST (assoc arrays are not ordered)
domain_order=(1 2 3 4 5 6 7 8 9 10)

# Run a domain by numeric key, with a given mode (default: full)
sr_run_domain() {
  local num="$1"; shift || true
  local mode="${1:-full}"
  local fn="${domain_map[$num]:-}"

  if [ -z "$fn" ]; then
    warn "No domain mapped for: $num"
    return 1
  fi

  # Time-wrapped + error-safe
  timer_wrap "$fn" sr_run_or_warn "$fn" "$mode"

  # Optional telemetry hook (domain-level event)
  if [ "${TELEM_ENABLED:-0}" = "1" ] && declare -F telemetry_domain_event >/dev/null; then
    telemetry_domain_event "$fn" "$mode" || true
  fi
}

# ALL MUST using the same map
sr_install_all_must() {
  say "üöÄ Installing ALL MUST tools across domains‚Ä¶"
  timer_start "all_must"
  for i in "${domain_order[@]}"; do
    sr_run_domain "$i" "must"
  done
  timer_end_say "all_must"

  # Optional telemetry for the full batch
  if [ "${TELEM_ENABLED:-0}" = "1" ] && declare -F telemetry_send_event >/dev/null; then
    telemetry_send_event "runner" "all_must" 0 "n/a" '{}' || true
  fi
}

# Run
preflight

# Menu loop
while true; do
  choice="$(sr_menu_main || true)"
  [ -n "${choice:-}" ] || continue

  case "${choice^^}" in
    [1-9]|10) sr_run_domain "$choice" "full" ;;
    A)        sr_install_all_must ;;
    Q)        printf "üëã Bye!\n"; exit 0 ;;
    *)        printf "‚ö†Ô∏è  Invalid choice: %s\n" "$choice" ;;
  esac
done
