#!/usr/bin/env bash
# NOTE: do NOT enable `set -u` here; this file is often sourced into interactive shells.
set -eo pipefail

# shellcheck disable=SC2034
VERSION="1.0.0"

# stack_refreshr alias manager (opt-in)
# Reads:   $SR_CONF/aliases.json
# Writes:  ~/.config/stack_refreshr/aliases_autogen.sh
# Sources: ~/.zshrc / ~/.bashrc idempotently (with backup before first write)
#
# Public funcs:
#   sr_apply_aliases    # generate & wire sourcing lines (backs up rc files once)
#   sr_remove_aliases   # remove sourcing lines (leaves generated file intact)

: "${SR_ROOT:=${PWD}}"
: "${SR_CONF:=${SR_ROOT}/configuration}"

SR_ALIASES_JSON="${SR_CONF}/aliases.json"
SR_ALIASES_DIR="${HOME}/.config/stack_refreshr"
SR_ALIASES_OUT="${SR_ALIASES_DIR}/aliases_autogen.sh"
SR_SOURCING_MARK="# >>> stack_refreshr: aliases >>>"
SR_SOURCING_MARK_END="# <<< stack_refreshr: aliases <<<"

_have() { command -v "$1" >/dev/null 2>&1; }

_backup_once() {
  local rc="$1"
  [ -f "$rc" ] || return 0
  # Only back up once per marker presence
  if grep -qF "$SR_SOURCING_MARK" "$rc" 2>/dev/null; then return 0; fi
  local stamp bak
  stamp="$(date +%Y%m%d_%H%M%S)"
  bak="${rc}.stack_refreshr.bak.${stamp}"
  cp "$rc" "$bak"
  printf "üóÑÔ∏è  Backed up %s -> %s\n" "$rc" "$bak"
}

_add_sourcing_line() {
  local rc="$1"
  [ -f "$rc" ] || return 0
  grep -qF "$SR_SOURCING_MARK" "$rc" 2>/dev/null && return 0
  _backup_once "$rc"
  {
    echo ""
    echo "$SR_SOURCING_MARK"
    echo "[ -f \"$SR_ALIASES_OUT\" ] && source \"$SR_ALIASES_OUT\""
    echo "$SR_SOURCING_MARK_END"
  } >> "$rc"
}

_remove_sourcing_line() {
  local rc="$1"
  [ -f "$rc" ] || return 0
  awk -v start="$SR_SOURCING_MARK" -v end="$SR_SOURCING_MARK_END" '
    $0 ~ start { skip=1; next }
    $0 ~ end   { skip=0; next }
    skip!=1 { print }
  ' "$rc" > "${rc}.tmp" && mv "${rc}.tmp" "$rc"
}

# Is the replacement command available? (checks first token)
_replacement_available() {
  local repl="$1"
  local first; first="$(printf '%s\n' "$repl" | awk '{print $1}')"
  _have "$first"
}

# Emit one alias line.
# - For simple commands: single-quoted body, prefix with `command` (prevents alias recursion).
# - For compound commands (spaces/&&/| or inner quotes): double-quoted body (so inner single quotes survive).
_emit_alias_line() {
  local name="$1" repl="$2" flags="${3:-}"
  local is_compound=0
  [[ "$repl" == *"&&"* || "$repl" == *"|"* || "$repl" == *" "* || "$repl" == *"'"* ]] && is_compound=1

  if [ "$is_compound" -eq 1 ]; then
    if [ -n "$flags" ]; then
      printf 'alias %s="%s %s"\n' "$name" "$repl" "$flags"
    else
      printf 'alias %s="%s"\n' "$name" "$repl"
    fi
  else
    if [ -n "$flags" ]; then
      printf "alias %s='command %s %s'\n" "$name" "$repl" "$flags"
    else
      printf "alias %s='command %s'\n" "$name" "$repl"
    fi
  fi
}

sr_apply_aliases() {
  if [ ! -f "$SR_ALIASES_JSON" ]; then
    printf "‚ö†Ô∏è  aliases.json not found at %s\n" "$SR_ALIASES_JSON" >&2
    return 1
  fi

  mkdir -p "$SR_ALIASES_DIR"
  : > "$SR_ALIASES_OUT"

  {
    echo "# Auto-generated by stack_refreshr"
    echo "# Do not edit; update ${SR_ALIASES_JSON} instead and re-run."
    echo
  } >> "$SR_ALIASES_OUT"

  # Robust iteration (base64 rows ‚Üí jq decode in the loop)
  while IFS= read -r row; do
    [ -n "$row" ] || continue
    local key repl flags reason
    key="$(  printf '%s' "$row" | base64 --decode | jq -r '.key' )"
    repl="$( printf '%s' "$row" | base64 --decode | jq -r '.value.replacement' )"
    flags="$(printf '%s' "$row" | base64 --decode | jq -r '.value.flags' )"
    reason="$(printf '%s' "$row" | base64 --decode | jq -r '.value.reasoning' )"

    # Compatibility skips: these caused issues when routed via bat
    if [ "$key" = "head" ] || [ "$key" = "tail" ] || [ "$key" = "less" ]; then
      printf "# skipped: alias %s ‚Üí %s%s (compatibility)\n" "$key" "$repl" "${flags:+ $flags}" >> "$SR_ALIASES_OUT"
      continue
    fi

    if _replacement_available "$repl"; then
      # Special handling for `cat`
      if [ "$key" = "cat" ]; then
        if [ -n "${VSCODE_SHELL_INTEGRATION:-}" ]; then
          printf "# skipped: alias cat ‚Üí %s (VS Code shell integration detected)\n" "$repl" >> "$SR_ALIASES_OUT"
        else
          # Wrapper function: `cat` with no args = real cat; with args = bat + flags
          {
            echo "cat() {"
            echo "  if [ \$# -eq 0 ]; then command cat; return; fi"
            if [ -n "$flags" ]; then
              echo "  command $repl $flags \"\$@\""
            else
              echo "  command $repl \"\$@\""
            fi
            echo "}"
          } >> "$SR_ALIASES_OUT"
        fi
      else
        _emit_alias_line "$key" "$repl" "$flags" >> "$SR_ALIASES_OUT"
      fi
    else
      printf "# skipped: alias %s ‚Üí %s (missing on PATH)\n" "$key" "$repl" >> "$SR_ALIASES_OUT"
    fi
  done < <(jq -r 'to_entries[] | @base64' "$SR_ALIASES_JSON")

  {
    echo
    echo "# --- reasoning (for humans) ---"
    jq -r 'to_entries[] | "# " + .key + " ‚Üí " + .value.replacement
      + (if .value.flags|length>0 then " " + .value.flags else "" end)
      + " ‚Äî " + .value.reasoning' "$SR_ALIASES_JSON"
  } >> "$SR_ALIASES_OUT"

  _add_sourcing_line "$HOME/.zshrc"
  _add_sourcing_line "$HOME/.bashrc"

  printf "‚úÖ Aliases generated: %s\n" "$SR_ALIASES_OUT"
  printf "‚ÑπÔ∏è  Sourced from ~/.zshrc (and ~/.bashrc if present). Restart shell or: source %s\n" "$SR_ALIASES_OUT"
}

sr_remove_aliases() {
  _remove_sourcing_line "$HOME/.zshrc"
  _remove_sourcing_line "$HOME/.bashrc"
  printf "‚úÖ Removed sourcing lines from rc files. Alias file left at: %s\n" "$SR_ALIASES_OUT"
}

# ---- aliases status ---------------------------------------------------------

_sr_have() { command -v "$1" >/dev/null 2>&1; }
_sr_first_token() { printf '%s\n' "$1" | awk '{print $1}'; }

# Print a status table for each alias from aliases.json.
# Usage:
#   sr_aliases_status           # pretty table
#   sr_aliases_status --json    # machine-readable JSON
sr_aliases_status() {
  if [ ! -f "$SR_ALIASES_JSON" ]; then
    printf "‚ö†Ô∏è  aliases.json not found at %s\n" "$SR_ALIASES_JSON" >&2
    return 1
  fi

  # Build rows
  # Each row: status<TAB>legacy<TAB>replacement<TAB>flags<TAB>reason
  mapfile -t ROWS < <(
    jq -r 'to_entries[] | @base64' "$SR_ALIASES_JSON" | while read -r row; do
      key=$(printf '%s' "$row" | base64 --decode | jq -r '.key')
      repl=$(printf '%s' "$row" | base64 --decode | jq -r '.value.replacement')
      flags=$(printf '%s' "$row" | base64 --decode | jq -r '.value.flags')
      reason=$(printf '%s' "$row" | base64 --decode | jq -r '.value.reasoning')
      first=$(_sr_first_token "$repl")
      if _sr_have "$first"; then
        printf "OK\t%s\t%s\t%s\t%s\n" "$key" "$repl" "$flags" "$reason"
      else
        printf "MISS\t%s\t%s\t%s\t%s\n" "$key" "$repl" "$flags" "$reason"
      fi
    done
  )

  if [ "${1:-}" = "--json" ]; then
    printf '[\n'
    sep=""
    for r in "${ROWS[@]}"; do
      status=$(printf '%s' "$r" | cut -f1)
      legacy=$(printf '%s' "$r" | cut -f2)
      repl=$(printf '%s' "$r" | cut -f3)
      flags=$(printf '%s' "$r" | cut -f4)
      reason=$(printf '%s' "$r" | cut -f5-)
      printf '%s{"status":"%s","legacy":"%s","replacement":"%s","flags":"%s","reason":"%s"}' \
        "$sep" "$status" "$legacy" "$repl" "$flags" "$reason"
      sep=",\n"
    done
    printf '\n]\n'
    return 0
  fi

  # Pretty print
  have_gum=0; command -v gum >/dev/null 2>&1 && have_gum=1

  header="STATUS  LEGACY  ‚Üí  REPLACEMENT  FLAGS"
  if [ $have_gum -eq 1 ]; then
    gum style --bold "$header"
  else
    printf '%s\n' "$header"
  fi

  for r in "${ROWS[@]}"; do
    status=$(printf '%s' "$r" | cut -f1)
    legacy=$(printf '%s' "$r" | cut -f2)
    repl=$(printf '%s' "$r" | cut -f3)
    flags=$(printf '%s' "$r" | cut -f4)

    mark="‚ùå"
    [ "$status" = "OK" ] && mark="‚úÖ"

    line=$(printf '%-3s  %-6s  ‚Üí  %-12s  %s' "$mark" "$legacy" "$repl" "$flags")
    if [ $have_gum -eq 1 ]; then
      if [ "$status" = "OK" ]; then
        gum style --foreground="#00D26A" "$line"
      else
        gum style --foreground="#FF5A5F" "$line"
      fi
    else
      printf '%s\n' "$line"
    fi
  done
}
